
[ParserGenerator(typeof(TemplateLexer), typeof(TemplateParser), typeof(object))]
public partial class TemplateParserGenerator
{
        
}

 [Lexer(IgnoreEOL = true)]
    public enum TemplateLexer
    {
 
        #region TEXT
   
        [UpTo("{%", "{=")]
        TEXT,
        
        [Sugar("{%")] [Push("code")] OPEN_CODE,
        
        [Sugar("{=")] [Push("value")] OPEN_VALUE,

    #endregion

    #region value

    [AlphaId]
    [Mode("value")]
    [Mode("code")]
    ID,
    
    [Sugar("=}")]
    [Mode("value")]
    [Pop]
    CLOSE_VALUE,

    #endregion
    
    #region code
    
    [Sugar("%}")]
    [Mode("code")]
    [Pop]
    CLOSE_CODE,
    
    [Keyword("if")]
    [Mode("code")]
    IF,
    
    [Keyword("endif")]
    [Mode("code")]
    ENDIF,
    
    [Keyword("else")]
    [Mode("code")]
    ELSE,
    
    [Keyword("for")] 
    [Mode("code")]
    FOR,

    [Keyword("as")] 
    [Mode("code")]
    AS,
    
    [Keyword("end")] 
    [Mode("code")]
    END,
    
    [Sugar("..")]
    [Mode("code")]
    RANGE,
    
    #region literals
    
    [String()]
    [Mode("code")]
    STRING,
    
    // [Int()]
    // [Mode("code")]
    // INT,
    
    [Int()]
    [Mode("code")]
    INT,
    
    [Lexeme(GenericToken.KeyWord, "TRUE")]
    [Lexeme(GenericToken.KeyWord, "true")]
    [Mode("code")]
    TRUE,

    [Lexeme(GenericToken.KeyWord, "FALSE")]
    [Lexeme(GenericToken.KeyWord, "false")]
    [Mode("code")]
    FALSE,
    
    
    
    #endregion
    
    #region operators 30 -> 49

    [Sugar( ">")]
    [Mode("code")]
    GREATER = 30,

    [Sugar( "<")]
    [Mode("code")]
    LESSER = 31,

    [Sugar( "==")]
    [Mode("code")]
    EQUALS = 32,

    [Sugar( "!=")]
    [Mode("code")]
    DIFFERENT = 33,

    [Sugar( "&")]
    [Mode("code")]
    CONCAT = 34,

    [Sugar( ":=")]
    [Mode("code")]
    ASSIGN = 35,

    [Sugar( "+")]
    [Mode("code")]
    PLUS = 36,

    [Sugar( "-")]
    [Mode("code")]
    MINUS = 37,


    [Sugar( "*")]
    [Mode("code")]
    TIMES = 38,

    [Sugar( "/")]
    [Mode("code")]
    DIVIDE = 39,
    
    
    #endregion
    
    #region sugar 100 -> 150
    
    [Sugar("(")]
    [Mode("code")]
    OPEN_PAREN,
    
    [Sugar(")")]
    [Mode("code")]
    CLOSE_PAREN,
    
    [Lexeme(GenericToken.KeyWord, "NOT")] [Lexeme(GenericToken.KeyWord, "not")]
    [Mode("code")]
    NOT,

    [Lexeme(GenericToken.KeyWord, "AND")] [Lexeme(GenericToken.KeyWord, "and")]
    [Mode("code")]
    AND,

    [Lexeme(GenericToken.KeyWord, "OR")] [Lexeme(GenericToken.KeyWord, "or")]
    [Mode("code")]
    OR,
    
    #endregion
    
    #endregion
        
    }


[ParserRoot("template")]
    public class TemplateParser
    {
        
        #region structure

        [Production("template: item*")]
        public object Template(List<object> items)
        {
            return null;
        }

        [Production("item : TEXT")]
        public object Text(Token<TemplateLexer> text)
        {
         return null;
        }
        
        [Production("item :OPEN_VALUE[d] ID CLOSE_VALUE[d]")]
        public object Value(Token<TemplateLexer> value)
        {
            return null;
        }

        [Production(@"item : OPEN_CODE[d] IF[d] OPEN_PAREN[d] TemplateParser_expressions CLOSE_PAREN[d] CLOSE_CODE[d]
                                     item* 
                                  elseBlock? 
                                  OPEN_CODE[d] ENDIF[d] CLOSE_CODE[d] ")]
        public object Conditional(Expression cond, List<object> thenBlock, ValueOption<object> elseBlock)
        {
            return null;
        }

        [Production("if : OPEN_CODE[d] IF[d] OPEN_PAREN[d] TemplateParser_expressions CLOSE_PAREN[d] CLOSE_CODE[d]")]
        public object If(object condition)
        {
            return null;
        }

        [Production("elseBlock : OPEN_CODE[d] ELSE[d] CLOSE_CODE[d] item*")]
        public object elseBlock(List<object> items)
        {
            return null;
        }
        

        [Production("item : OPEN_CODE[d] FOR[d] INT RANGE[d] INT AS[d] ID CLOSE_CODE[d] item* OPEN_CODE[d] END[d] CLOSE_CODE[d]")]
        public object fori(Token<TemplateLexer> start, Token<TemplateLexer> end, Token<TemplateLexer> iterator, List<object> items)
        {
            return null;
        }
        
        [Production("item : OPEN_CODE[d] FOR[d] ID AS[d] ID CLOSE_CODE[d] item* OPEN_CODE[d] END[d] CLOSE_CODE[d]")]
        public object _foreach(Token<TemplateLexer> listName, Token<TemplateLexer> iterator, List<object> items)
        {
            return null;
        }
       
        #endregion
        
        #region COMPARISON OPERATIONS

        [Infix("LESSER", Associativity.Right, 50)]
        [Infix("GREATER", Associativity.Right, 50)]
        [Infix("EQUALS", Associativity.Right, 50)]
        [Infix("DIFFERENT", Associativity.Right, 50)]
        public Expression binaryComparisonExpression(Expression left, Token<TemplateLexer> operatorToken,
            Expression right)
        {
            
            return null;
        }

        #endregion

        #region STRING OPERATIONS

        // [Operation((int) TemplateLexer.CONCAT, Affix.InFix, Associativity.Right, 10)]
        // public Expression binaryStringExpression(Expression left, Token<TemplateLexer> operatorToken, Expression right)
        // {
        //     return null;
        // }

        #endregion
        
          #region OPERANDS

          
        [Production("primary: INT")]
        public Expression PrimaryInt(Token<TemplateLexer> intToken)
        {
            return null;
        }

        
        [Production("primary: TRUE")]
        [Production("primary: FALSE")]
        public object PrimaryBool(Token<TemplateLexer> boolToken)
        {
            return null;
        }

        
        [Production("primary: STRING")]
        public object PrimaryString(Token<TemplateLexer> stringToken)
        {
            return null;
        }

        
        [Production("primary: ID")]
        public Expression PrimaryId(Token<TemplateLexer> varToken)
        {
            return null;
        }

        [Operand]
        [Production("operand: primary")]
        public Expression Operand(Expression prim)
        {
            return null;
        }

        #endregion

        #region NUMERIC OPERATIONS

        [Operation((int) TemplateLexer.PLUS, Affix.InFix, Associativity.Right, 10)]
        [Operation((int) TemplateLexer.MINUS, Affix.InFix, Associativity.Right, 10)]
        public Expression binaryTermNumericExpression(Expression left, Token<TemplateLexer> operatorToken,
            Expression right)
        {
           return null;
        }

        [Operation((int) TemplateLexer.TIMES, Affix.InFix, Associativity.Right, 50)]
        [Operation((int) TemplateLexer.DIVIDE, Affix.InFix, Associativity.Right, 50)]
        public Expression binaryFactorNumericExpression(Expression left, Token<TemplateLexer> operatorToken,
            Expression right)
        {
            return null;
        }

        [Prefix((int) TemplateLexer.MINUS, Associativity.Right, 100)]
        public Expression unaryNumericExpression(Token<TemplateLexer> operation, Expression value)
        {
            return null;
        }

        #endregion


        #region BOOLEAN OPERATIONS

        [Operation((int) TemplateLexer.OR, Affix.InFix, Associativity.Right, 10)]
        public Expression binaryOrExpression(Expression left, Token<TemplateLexer> operatorToken, Expression right)
        {
            return null;
        }

        [Operation((int) TemplateLexer.AND, Affix.InFix, Associativity.Right, 50)]
        public Expression binaryAndExpression(Expression left, Token<TemplateLexer> operatorToken, Expression right)
        {
            return null;
        }

        [Operation((int) TemplateLexer.NOT, Affix.PreFix, Associativity.Right, 100)]
        public Expression binaryOrExpression(Token<TemplateLexer> operatorToken, Expression value)
        {
            return null;
        }

        #endregion
    }